#@ load("@ytt:md5", "md5")
#@ load("@ytt:data", "data")
#@ load("@ytt:json", "json")
#@ load("@ytt:sha256", "sha256")
#@ load("@ytt:base64", "base64")

#@ configMD5 = md5.sum(json.encode(data.values))
#@ configSHA256 = sha256.sum(json.encode(data.values))
#@ configEncoded = base64.encode(json.encode(data.values))

#@ globalLabels = {}
#@ globalLabels.update({ "ecosystem": data.values.ecosystem })
#@ globalLabels.update({ "environment": data.values.environment })

#@ globalAnnotations = {}
#@ globalAnnotations.update({ "pipe/config-md5": configMD5 })
#@ globalAnnotations.update({ "pipe/config-sha256": configSHA256 })
#@ globalAnnotations.update({ "pipe/ecosystem": data.values.ecosystem })
#@ globalAnnotations.update({ "pipe/environment": data.values.environment })
#@ globalAnnotations.update({ "pipe/updated-at": data.values.pipelineControl.datetime })
#@ globalAnnotations.update({ "kubectl.kubernetes.io/last-applied-configuration": data.values.pipelineControl.datetime })

---
apiVersion: v1
kind: Namespace
metadata:
  #@ if data.values.pipelineControl.environmentsAsNamespaces:
  #@  namespace = "{}-{}".format(data.values.repository, data.values.environment)
  #@ else:
  #@  namespace = data.values.repository
  #@ end
  name: #@ namespace

  #@ namespaceLabels = {}
  #@ namespaceLabels.update(data.values.namespace.labels)
  #@ namespaceLabels.update(globalLabels)
  labels: #@ namespaceLabels

  #@ namespaceAnnotations = {}
  #@ namespaceAnnotations.update(data.values.namespace.annotations)
  #@ namespaceAnnotations.update(globalAnnotations)
  #@ if data.values.features.enableLinkerd:
  #@  namespaceAnnotations.update({ "linkerd.io/inject": "enabled" })
  #@ end
  annotations: #@ namespaceAnnotations

---
apiVersion: v1
kind: Secret
type: Opaque
metadata:
  name: pipeline
  namespace: #@ namespace

  #@ secretAnnotations = {}
  #@ secretAnnotations.update(globalAnnotations)
  annotations: #@ secretAnnotations
data:
  data: #@ configEncoded
  config-md5: #@ configMD5
  config-sha256: #@ configSHA256

---
#@ if data.values.deployment.enable:
apiVersion: apps/v1
kind: Deployment
metadata:
  name: #@ data.values.deployment.name
  namespace: #@ namespace

  #@ deploymentLabels = {}
  #@ deploymentLabels.update(globalLabels)
  #@ deploymentLabels.update(data.values.deployment.labels)
  labels: #@ deploymentLabels

  #@ deploymentAnnotations = {}
  #@ deploymentAnnotations.update(globalAnnotations)
  #@ deploymentAnnotations.update(data.values.deployment.annotations)
  annotations: #@ deploymentAnnotations
spec:
  replicas: #@ data.values.deployment.replicas

  selector:
    #@ if data.values.deployment.matchLabels.overwrite:
    matchLabels: #@ data.values.deployment.matchLabels.labels
    #@ else:
    #@ deploymentMatchLabels = {}
    #@ deploymentMatchLabels.update({ "pipe/selector": data.values.repository + "." + data.values.deployment.name })
    matchLabels: #@ deploymentMatchLabels
    #@ end
  template:
    metadata:
      #@ deploymentTemplateLabels = {}
      #@ deploymentTemplateLabels.update(globalLabels)
      #@ deploymentTemplateLabels.update({ "pipe/selector": data.values.repository + "." + data.values.deployment.name })
      #@ deploymentTemplateLabels.update(data.values.deployment.templateLabels)
      labels: #@ deploymentTemplateLabels
    spec:
      restartPolicy: Always

      #@ if/end data.values.deployment.imagePullSecrets:
      imagePullSecrets:
        - name: registry-token

      containers:
        - name: #@ data.values.deployment.name
          image: #@ "{}/{}/{}:{}".format(data.values.containerRegistry, data.values.organization, data.values.repository, data.values.tag)
          imagePullPolicy: Always
          resources: #@ data.values.deployment.resources

          #@ deploymentEnvs = []
          #@ deploymentEnvs.extend(data.values.env)
          
          #@ for i in data.values.envFromConfigMaps:
          #@   deploymentEnvs.extend([{ 
          #@    "name": i, 
          #@    "valueFrom": {
          #@      "configMapKeyRef": {
          #@        "name": "svc",
          #@        "key": i,
          #@      }
          #@    }
          #@   }])
          #@ end
          
          #@ for i in data.values.envFromSecrets:
          #@   deploymentEnvs.extend([{ 
          #@    "name": i, 
          #@    "valueFrom": {
          #@      "secretKeyRef": {
          #@        "name": "svc",
          #@        "key": i,
          #@      }
          #@    }
          #@   }])
          #@ end
          
          #@ for i in data.values.envFromDependencies:
          #@   deploymentEnvs.extend([{ 
          #@    "name": (i + "_connection_string").upper(),
          #@    "valueFrom": {
          #@      "configMapKeyRef": {
          #@        "name": "svc-" + i,
          #@        "key": "connection-string",
          #@      }
          #@    }
          #@   }])
          #@ end
          env: #@ deploymentEnvs
#@ end

---
#@ if data.values.service.enable:
apiVersion: v1
kind: Service
metadata:
  name: #@ data.values.service.name
  namespace: #@ namespace

  #@ serviceLabels = {}
  #@ serviceLabels.update(globalLabels)
  #@ serviceLabels.update(data.values.service.labels)
  labels: #@ serviceLabels

  #@ serviceAnnotations = {}
  #@ serviceAnnotations.update(globalAnnotations)
  #@ serviceAnnotations.update(data.values.service.annotations)
  annotations: #@ serviceAnnotations
spec:
  #@ if data.values.service.selector.overwrite:
  selector: #@ data.values.service.selector.labels
  #@ else:
  #@ serviceMatchLabels = {}
  #@ serviceMatchLabels.update({ "pipe/selector": data.values.repository + "." + data.values.deployment.name })
  selector: #@ serviceMatchLabels
  #@ end

  #@ servicePorts = []
  #@ servicePorts.extend(data.values.service.ports)
  #@ servicePorts.extend([
  #@   { "name": "http", "protocol": "TCP", "port": data.values.deployment.port, "targetPort": data.values.deployment.port }
  #@ ])
  ports: #@ servicePorts
#@ end

#@ if data.values.ingress.enable:
---
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: letsencrypt
  namespace: #@ namespace
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: #@ data.values.ingress.domain.email
    privateKeySecretRef:
      name: letsencrypt
    solvers:
      - http01:
          ingress:
            class: nginx

---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: #@ data.values.ingress.name
  namespace: #@ namespace
  annotations:
    cert-manager.io/issuer: "letsencrypt"

    #@ if data.values.ingress.type == "alb":
    kubernetes.io/ingress.class: alb
    alb.ingress.kubernetes.io/ssl-redirect: "443"
    alb.ingress.kubernetes.io/success-codes: 200-399
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/ssl-policy: ELBSecurityPolicy-2016-08
    alb.ingress.kubernetes.io/group.name: #@ data.values.ecosystem
    alb.ingress.kubernetes.io/load-balancer-name: #@ data.values.ecosystem
    alb.ingress.kubernetes.io/certificate-arn: #@ data.values.ingress.alb.certificateArn
    #@ end

spec:
  #@ if data.values.ingress.type == "nginx":
  ingressClassName: nginx
  #@ end

  #@ if data.values.ingress.domain.enable:
  tls:
    - secretName: #@ "cert-" + data.values.repository
      hosts:
      - #@ "{}.{}.{}".format(data.values.repository, data.values.environment, data.values.ingress.domain.name)
  #@ end

  defaultBackend:
    service:
      name: #@ data.values.deployment.name
      port:
        number: #@ data.values.deployment.port
  
  rules:
    - http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: #@ data.values.deployment.name
                port:
                  number: #@ data.values.deployment.port
      #@ if data.values.ingress.domain.enable:
      host: #@ "{}.{}.{}".format(data.values.repository, data.values.environment, data.values.ingress.domain.name)
      #@ end
#@ end
